var BaseService, HttpError, Promise, REGEX_LAST, SphereHttpError, Utils, debug, _, _ref;

debug = require('debug')('sphere-client');

_ = require('underscore');

_.mixin(require('underscore-mixins'));

Promise = require('bluebird');

Utils = require('../utils');

_ref = require('../errors'), HttpError = _ref.HttpError, SphereHttpError = _ref.SphereHttpError;


/**
 * @const
 * RegExp to parse time period for last function.
 */

REGEX_LAST = /^(\d+)([s|m|h|d|w])$/;


/**
 * Creates a new BaseService, containing base functionalities. It should be extended when defining a Service.
 * @class BaseService
 */

BaseService = (function() {

  /**
   * @const
   * @private
   * Base path for a API resource endpoint (to be overriden by specific service)
   * @type {String}
   */
  BaseService.baseResourceEndpoint = '';


  /**
   * Initialize the class.
   * @constructor
   * @param {Object} opts An object containing configuration option and/or instances of {Rest}, {TaskQueue}
   */

  function BaseService(opts) {
    if (opts == null) {
      opts = {};
    }
    this._rest = opts._rest, this._task = opts._task, this._stats = opts._stats;
    this._setDefaults();
  }


  /**
   * @private
   * Reset default _currentEndpoint and _params used to build request endpoints
   */

  BaseService.prototype._setDefaults = function() {

    /**
     * @private
     * Current path for a API resource endpoint which can be modified by appending ids, queries, etc
     * @type {String}
     */
    this._currentEndpoint = this.constructor.baseResourceEndpoint;

    /**
     * @private
     * Container that holds request parameters such `id`, `query`, etc
     * @type {Object}
     */
    return this._params = {
      encoded: ['where', 'expand', 'sort'],
      query: {
        where: [],
        operator: 'and',
        sort: [],
        expand: []
      }
    };
  };


  /**
   * Build the endpoint path by appending the given id
   * @param {String} id The resource specific id
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.byId = function(id) {
    this._currentEndpoint = "" + this.constructor.baseResourceEndpoint + "/" + id;
    this._params.id = id;
    debug('setting endpoint id: %j', this._currentEndpoint);
    return this;
  };


  /**
   * Define a {Predicate} used for quering and filtering a resource.
   * @link http://commercetools.de/dev/http-api.html#predicates
   * @param {String} [predicate] A {Predicate} string for the `where` query parameter.
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.where = function(predicate) {
    var encodedPredicate;
    if (!predicate) {
      return this;
    }
    encodedPredicate = encodeURIComponent(predicate);
    this._params.query.where.push(encodedPredicate);
    debug('setting predicate: %s', predicate);
    return this;
  };


  /**
   * Define the logical operator to combine multiple `where` query parameters.
   * @param {String} [operator] A logical operator (default `and`)
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.whereOperator = function(operator) {
    if (operator == null) {
      operator = 'and';
    }
    this._params.query.operator = (function() {
      switch (operator) {
        case 'and':
        case 'or':
          return operator;
        default:
          return 'and';
      }
    })();
    debug('setting where operator: %s', operator);
    return this;
  };


  /**
   * This is a convenient method to query for the latest changes.
   * @param {String} period time period of format "numberX" where "X" is one of the follwing units:
   * s -> seconds
   * m -> minutes
   * h -> hours
   * d -> days
   * w -> weeks
   * @throws {Error} If period cannot be parsed
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.last = function(period) {
    var amount, before, dateTime, matches, now;
    if (!REGEX_LAST.test(period)) {
      throw new Error("Cannot parse period '" + period + "'");
    }
    matches = REGEX_LAST.exec(period);
    amount = matches[1];
    if (amount === '0') {
      return this;
    }
    before = Utils.getTime(amount, matches[2]);
    now = new Date().getTime();
    dateTime = new Date(now - before).toISOString();
    return this.where("lastModifiedAt > \"" + dateTime + "\"");
  };


  /**
   * Define how the query should be sorted.
   * It is possible to add several sort criteria, thereby the order is relevant.
   * @param {String} path Sort path to search for
   * @param {Boolean} [ascending] Whether the direction should be ascending or not, (default `asc`)
   *                              `true` = asc, `false` = desc
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.sort = function(path, ascending) {
    var direction;
    if (ascending == null) {
      ascending = true;
    }
    direction = ascending ? 'asc' : 'desc';
    this._params.query.sort.push(encodeURIComponent("" + path + " " + direction));
    debug('setting sort: %s %s', path, direction);
    return this;
  };


  /**
   * Define the page number to be requested from the complete query result
   * (used for pagination as `offset`)
   * @param {Number} page A number >= 1 (default is 1)
   * @throws {Error} If argument is not a number >= 1
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.page = function(page) {
    if (_.isNumber(page) && page < 1) {
      throw new Error('Page must be a number >= 1');
    }
    this._params.query.page = page;
    debug('setting page: %s', page);
    return this;
  };


  /**
   * Define the number of results to return from a query
   * (used for pagination as `limit`)
   * @see _pagedFetch if limit is `0` (all results)
   * @param {Number} perPage A number >= 0 (default is 100)
   * @throws {Error} If argument is not a number >= 0
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.perPage = function(perPage) {
    if (_.isNumber(perPage) && perPage < 0) {
      throw new Error('PerPage (limit) must be a number >= 0');
    }
    this._params.query.perPage = perPage;
    debug('setting perPage: %s', perPage);
    return this;
  };


  /**
   * Alias for {@link perPage(0)}.
   */

  BaseService.prototype.all = function() {
    return this.perPage(0);
  };


  /**
   * Define an {ExpansionPath} used for expanding {Reference}s of a resource.
   * @link http://commercetools.de/dev/http-api.html#reference-expansion
   * @param {String} [expansionPath] An {ExpansionPath} string for the `expand` query parameter.
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.expand = function(expansionPath) {
    var encodedExpansionPath;
    if (!expansionPath) {
      return this;
    }
    encodedExpansionPath = encodeURIComponent(expansionPath);
    this._params.query.expand.push(encodedExpansionPath);
    debug('setting expand: %s', expansionPath);
    return this;
  };

  BaseService.prototype.byQueryString = function(query, withEncodedParams) {
    var parsed;
    if (withEncodedParams == null) {
      withEncodedParams = false;
    }
    parsed = _.parseQuery(query, false);
    if (!withEncodedParams) {
      _.each(this._params.encoded, function(param) {
        if (parsed[param]) {
          return parsed[param] = _.map(_.flatten([parsed[param]]), function(p) {
            return encodeURIComponent(p);
          });
        }
      });
    }
    this._params.queryString = _.stringifyQuery(parsed);
    debug('setting queryString: %s', query);
    return this;
  };


  /**
   * @private
   * Build a query string from (pre)defined params
   * (to be overriden for custom params)
   * @return {String} the query string
   */

  BaseService.prototype._queryString = function() {
    var qs;
    qs = this._params.queryString ? this._params.queryString : Utils.buildQueryString({
      where: this._params.query.where,
      whereOperator: this._params.query.operator,
      page: this._params.query.page,
      perPage: this._params.query.perPage,
      sort: this._params.query.sort,
      expand: this._params.query.expand
    });
    debug('built query string: %s', qs);
    return qs;
  };


  /**
   * Fetch resource defined by _currentEndpoint with query parameters
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype.fetch = function() {
    var _getEndpoint;
    _getEndpoint = (function(_this) {
      return function() {
        var endpoint, queryString;
        queryString = _this._queryString();
        endpoint = _this._currentEndpoint;
        if (queryString) {
          endpoint += "?" + queryString;
        }
        return endpoint;
      };
    })(this);
    if (!this._params.queryString && this._params.query.perPage === 0) {
      if (_.isEmpty(this._params.query.sort)) {
        this.sort('id');
      }
      return this._paged(_getEndpoint());
    } else {
      return this._get(_getEndpoint());
    }
  };


  /**
   * Process the resources for each page separatly using the function fn.
   * The function fn will then be called once for per page.
   * The function fn has to return a promise that should be resolved when all elements of the page are processed.
   * @param {Function} fn The function to process a page that returns a promise
   * @throws {Error} If argument is not a function
   * @return {Promise} A promise, fulfilled with an array of the resolved results of function fn or the rejected result of fn
   * @example
   *   page(3).perPage(5) will start processing at element 10, gives you a payload of 5 elements per call of fn again and again until all elements are processed.
   */

  BaseService.prototype.process = function(fn, options) {
    if (options == null) {
      options = {};
    }
    if (!_.isFunction(fn)) {
      throw new Error('Please provide a function to process the elements');
    }
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var endpoint, originalQuery, _processPage;
        options = _.defaults(options, {
          accumulate: true
        });
        endpoint = _this.constructor.baseResourceEndpoint;
        originalQuery = _this._params.query;
        _processPage = function(page, perPage, total, acc) {
          var queryString;
          if (acc == null) {
            acc = [];
          }
          debug('processing next page with params: %j', {
            page: page,
            perPage: perPage,
            offset: (page - 1) * perPage,
            total: total
          });
          if ((total != null) && (page - 1) * perPage >= total) {
            return resolve(acc);
          } else {
            _this._params.query = _.extend({}, originalQuery, {
              page: page,
              perPage: perPage
            });
            if (_.isEmpty(_this._params.query.sort)) {
              _this.sort('id');
            }
            queryString = _this._queryString();
            return _this._get("" + endpoint + "?" + queryString).then(function(payload) {
              return fn(payload).then(function(result) {
                var accumulated, newTotal, nextPage;
                newTotal = payload.body.total;
                if (!total || total === newTotal) {
                  nextPage = page + 1;
                } else if (total < newTotal) {
                  nextPage = page;
                  debug('Total is bigger then before, assuming something has been newly created. Processing the same page (%s).', nextPage);
                } else {
                  nextPage = page - 1;
                  if (nextPage < 1) {
                    nextPage = 1;
                  }
                  debug('Total is lesser then before, assuming something has been deleted. Reducing page to %s (min 1).', nextPage);
                }
                if (options.accumulate) {
                  accumulated = acc.concat(result);
                }
                return _processPage(nextPage, perPage, newTotal, accumulated);
              });
            })["catch"](function(error) {
              return reject(error);
            }).done();
          }
        };
        return _processPage(_this._params.query.page || 1, _this._params.query.perPage || 20);
      };
    })(this));
  };


  /**
   * Save a new resource by sending a payload to the _currentEndpoint, describing
   * the new resource model.
   * If the `id` was provided, the API expects the request to be an update by
   * by providing a payload of {UpdateAction}.
   * @param {Object} body The payload as JSON object
   * @throws {Error} If body is not given
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype.save = function(body) {
    var endpoint;
    if (!body) {
      throw new Error("Body payload is required for creating a resource (endpoint: " + this.constructor.baseResourceEndpoint + ")");
    }
    endpoint = this.constructor.baseResourceEndpoint;
    return this._save(endpoint, body);
  };


  /**
   * Alias for {@link save}.
   */

  BaseService.prototype.create = function() {
    return this.save.apply(this, arguments);
  };


  /**
   * Alias for {@link save}, as it's the same type of HTTP request.
   * Updating a resource is done by sending a list of {UpdateAction}.
   * (more intuitive way of describing an update, given that an [id] is provided)
   * @example `{service}.byId({id}).update({actions})`
   */

  BaseService.prototype.update = function(body) {
    var endpoint;
    if (!this._params.id) {
      throw new Error("Missing resource id. You can set it by chaining '.byId(ID)'");
    }
    if (!body) {
      throw new Error("Body payload is required for updating a resource (endpoint: " + this._currentEndpoint + ")");
    }
    endpoint = this._currentEndpoint;
    return this._save(endpoint, body);
  };


  /**
   * Delete an existing resource of the _currentEndpoint
   * If the `id` was provided, the API expects this to be a resource update with given {UpdateAction}
   * @param {Number} version The current version of the resource
   * @throws {Error} If version is not given
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype["delete"] = function(version) {
    var endpoint;
    if (!version) {
      throw new Error("Version is required for deleting a resource (endpoint: " + this._currentEndpoint + ")");
    }
    endpoint = "" + this._currentEndpoint + "?version=" + version;
    return this._delete(endpoint);
  };


  /**
   * Return a {Promise} for a GET call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._get = function(endpoint) {
    this._setDefaults();
    return this._task.addTask((function(_this) {
      return function() {
        var originalRequest;
        originalRequest = {
          endpoint: endpoint
        };
        return new Promise(function(resolve, reject) {
          return _this._rest.GET(endpoint, function() {
            return _this._wrapResponse.apply(_this, [resolve, reject, originalRequest].concat(_.toArray(arguments)));
          });
        });
      };
    })(this));
  };


  /**
   * Return a {Promise} for a PAGED call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._paged = function(endpoint) {
    this._setDefaults();
    return this._task.addTask((function(_this) {
      return function() {
        var originalRequest;
        originalRequest = {
          endpoint: endpoint
        };
        return new Promise(function(resolve, reject) {
          return _this._rest.PAGED(endpoint, function() {
            return _this._wrapResponse.apply(_this, [resolve, reject, originalRequest].concat(_.toArray(arguments)));
          });
        });
      };
    })(this));
  };


  /**
   * Return a {Promise} for a POST call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @param {String} payload The body payload as a String
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._save = function(endpoint, payload) {
    this._setDefaults();
    return this._task.addTask((function(_this) {
      return function() {
        var originalRequest;
        originalRequest = {
          endpoint: endpoint,
          payload: payload
        };
        return new Promise(function(resolve, reject) {
          return _this._rest.POST(endpoint, payload, function() {
            return _this._wrapResponse.apply(_this, [resolve, reject, originalRequest].concat(_.toArray(arguments)));
          });
        });
      };
    })(this));
  };


  /**
   * Return a {Promise} for a DELETE call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._delete = function(endpoint) {
    this._setDefaults();
    return this._task.addTask((function(_this) {
      return function() {
        var originalRequest;
        originalRequest = {
          endpoint: endpoint
        };
        return new Promise(function(resolve, reject) {
          return _this._rest.DELETE(endpoint, function() {
            return _this._wrapResponse.apply(_this, [resolve, reject, originalRequest].concat(_.toArray(arguments)));
          });
        });
      };
    })(this));
  };


  /**
   * @private
   * Wrap responses and decide whether to reject or resolve the promise
   * @param {Function} resolve The function called to resolve the promise
   * @param {Function} reject The function called to reject the promise
   * @param {Object} error An error object when applicable (usually from `http.ClientRequest` object) otherwise `null`
   * @param {Object} response An `http.IncomingMessage` object containing all kind of information about the request / response
   * @param {Object} body A JSON object containing the HTTP API resource or error messages
   */

  BaseService.prototype._wrapResponse = function(resolve, reject, originalRequest, error, response, body) {
    var endpoint, errorBody, errorMessage, errorResp, responseJson, _ref1;
    responseJson = this._stats.includeHeaders ? {
      http: {
        request: {
          method: response.request.method,
          httpVersion: response.httpVersion,
          uri: response.request.uri,
          header: response.req._header,
          headers: response.request.headers
        },
        response: {
          headers: response.headers
        }
      }
    } : {};
    if (error) {
      if (error instanceof Error) {
        errorMessage = error.message;
      } else {
        errorMessage = error;
      }
      errorResp = {
        statusCode: (response != null ? response.statusCode : void 0) || 500,
        message: errorMessage,
        originalRequest: originalRequest
      };
      if (body) {
        errorResp.body = body;
      }
      errorBody = _.extend(responseJson, errorResp);
      return reject(new HttpError(errorMessage, errorBody));
    } else {
      if ((200 <= (_ref1 = response.statusCode) && _ref1 < 300)) {
        return resolve(_.extend(responseJson, {
          statusCode: response.statusCode,
          body: body
        }));
      } else if (response.statusCode === 404) {
        endpoint = response.request.uri.path;
        return reject(new SphereHttpError.NotFound("Endpoint '" + endpoint + "' not found.", _.extend(responseJson, {
          statusCode: 404,
          message: "Endpoint '" + endpoint + "' not found.",
          originalRequest: originalRequest
        })));
      } else {
        errorMessage = body.message || 'Undefined SPHERE.IO error message';
        errorBody = _.extend(responseJson, body, {
          statusCode: body.statusCode || response.statusCode,
          originalRequest: originalRequest
        });
        return reject((function() {
          switch (body.statusCode) {
            case 400:
              return new SphereHttpError.BadRequest(errorMessage, errorBody);
            case 409:
              return new SphereHttpError.ConcurrentModification(errorMessage, errorBody);
            case 500:
              return new SphereHttpError.InternalServerError(errorMessage, errorBody);
            case 503:
              return new SphereHttpError.ServiceUnavailable(errorMessage, errorBody);
            default:
              return new HttpError(require('http').STATUS_CODES[response.statusCode], _.extend(responseJson, {
                statusCode: response.statusCode,
                originalRequest: originalRequest
              }));
          }
        })());
      }
    }
  };

  return BaseService;

})();


/**
 * The {@link BaseService} service.
 */

module.exports = BaseService;
