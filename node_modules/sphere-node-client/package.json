{
  "name": "sphere-node-client",
  "description": "Officially supported Node.js client library for accessing SPHERE.IO HTTP API, with OAuth2 support.",
  "version": "0.8.1",
  "homepage": "https://github.com/sphereio/sphere-node-client",
  "author": {
    "name": "Nicola Molinari",
    "email": "nicola.molinari@commercetools.de"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/sphereio/sphere-node-client.git"
  },
  "bugs": {
    "url": "https://github.com/sphereio/sphere-node-client/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/sphereio/sphere-node-client/blob/master/LICENSE-MIT"
    }
  ],
  "main": "./lib/client",
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "build": "grunt build",
    "postpublish": "rm -rf lib",
    "test": "grunt coverage"
  },
  "dependencies": {
    "q": "1.0.1",
    "sphere-node-connect": "0.5.7",
    "sphere-node-utils": "0.4.13",
    "underscore": "1.6.0"
  },
  "devDependencies": {
    "coveralls": "2.10.0",
    "grunt": "0.4.4",
    "grunt-bump": "0.0.13",
    "grunt-coffeelint": "0.0.8",
    "grunt-contrib-clean": "0.5.0",
    "grunt-contrib-coffee": "0.10.1",
    "grunt-contrib-concat": "0.4.0",
    "grunt-contrib-watch": "0.6.1",
    "grunt-shell": "0.6.4",
    "istanbul": "0.2.7",
    "jasmine-node": "1.13.1",
    "sphere-coffeelint": "git://github.com/sphereio/sphere-coffeelint.git#master"
  },
  "keywords": [
    "sphere",
    "sphereio",
    "rest",
    "api",
    "sdk",
    "ecommerce"
  ],
  "readme": "![SPHERE.IO icon](https://admin.sphere.io/assets/images/sphere_logo_rgb_long.png)\n\n# Node.js Client\n\n[![NPM](https://nodei.co/npm/sphere-node-client.png?downloads=true)](https://www.npmjs.org/package/sphere-node-client)\n\n[![Build Status](https://secure.travis-ci.org/sphereio/sphere-node-client.png?branch=master)](http://travis-ci.org/sphereio/sphere-node-client) [![NPM version](https://badge.fury.io/js/sphere-node-client.png)](http://badge.fury.io/js/sphere-node-client) [![Coverage Status](https://coveralls.io/repos/sphereio/sphere-node-client/badge.png?branch=master)](https://coveralls.io/r/sphereio/sphere-node-client?branch=master) [![Dependency Status](https://david-dm.org/sphereio/sphere-node-client.png?theme=shields.io)](https://david-dm.org/sphereio/sphere-node-client) [![devDependency Status](https://david-dm.org/sphereio/sphere-node-client/dev-status.png?theme=shields.io)](https://david-dm.org/sphereio/sphere-node-client#info=devDependencies)\n\n[SPHERE.IO](http://sphere.io/) is the first **Platform-as-a-Service** solution for eCommerce.\n\nThis module is a standalone Node.js client for accessing the Sphere HTTP APIs.\n\n## Table of Contents\n* [Getting Started](#getting-started)\n* [Documentation](#documentation)\n  * [Services](#services)\n  * [Types of requests](#types-of-requests)\n    * [Task Queue](#task-queue)\n    * [Query request](#query-request)\n      * [Query all (limit 0)](#query-all-limit0)\n      * [Query for modifications](#query-for-modifications)\n      * [Query and process in batches](#query-and-process-in-batches)\n      * [Staged products](#staged-products)\n    * [Search request](#search-request)\n    * [Create resource](#create-resource)\n      * [Import orders](#import-orders)\n      * [Ensure channels](#ensure-channels)\n    * [Update resource](#update-resource)\n    * [Delete resource](#delete-resource)\n  * [Types of responses](#types-of-responses)\n  * [Error handling](#error-handling)\n  * [Logging](#logging)\n  * [Statistics](#statistics)\n* [Examples](#examples)\n* [Releasing](#releasing)\n* [License](#license)\n\n\n## Getting Started\nInstall the module with `npm install sphere-node-client`\n\n```coffeescript\nSphereClient = require 'sphere-node-client'\n```\n\n## Documentation\nTo start using the Sphere client you need to create an instance of the `SphereClient` by passing the credentials (and other options) in order to connect with the HTTP APIs. Project credentials can be found in the SPHERE.IO [Merchant Center](https://admin.sphere.io/) under `Developers > API clients` section.\n\n> For a list of options to pass to the client, see [`sphere-node-connect`](https://github.com/sphereio/sphere-node-connect#documentation).\n\n```coffeescript\nclient = new SphereClient\n  config:\n    client_id: \"CLIENT_ID_HERE\"\n    client_secret: \"CLIENT_SECRET_HERE\"\n    project_key: \"PROJECT_KEY_HERE\"\n```\n\n### Services\nThe `SphereClient` provides a set of Services to connect with the related API endpoints. Currently following services are supported:\n\n- `carts`\n- `categories`\n- `channels`\n- `comments`\n- `customObjects`\n- `customerGroups`\n- `customers`\n- `inventoryEntries`\n- `messages`\n- `orders`\n- `productDiscounts`\n- `productProjections`\n- `productTypes`\n- `products`\n- `project`\n- `reviews`\n- `shippingMethods`\n- `states`\n- `taxCategories`\n- `zones`\n\n> Note that not all services support the common (CRUD) verbs, it depends on the resource endpoint itself. Please refer to the [HTTP API Documentation](http://dev.sphere.io/).\n\n### Types of requests\nRequests to the HTTP API are obviously asynchronous and they all return a [`Q` promise](https://github.com/kriskowal/q).\n\n```coffeescript\nclient = new SphereClient {...}\n\nclient.products.fetch()\n.then (result) ->\n  # a JSON object containing a statusCode and a body of either a result or a SPHERE.IO HTTP error\n.fail (error) ->\n  # either the request failed or was rejected (the response returned an error)\n```\n\nCurrent methods using promises are:\n\n- `fetch` HTTP `GET` request\n- `save` HTTP `POST` request\n- `create` HTTP `POST` request (_alias for `save`_)\n- `update` HTTP `POST` request\n- `delete` HTTP `DELETE` request\n\n#### Task Queue\nTo optimize processing lots of requests all together, e.g.: avoiding connection timeouts, we introduced [TaskQueue](https://github.com/sphereio/sphere-node-utils#taskqueue).\n\nEvery request is internally pushed in a queue which automatically starts resolving promises (requests) and will process concurrently some of them based on the `maxParallel` parameter. You can set this parameter by calling the following method\n- `setMaxParallel(n)` defines the number of max parallel requests to be processed by the [TaskQueue](https://github.com/sphereio/sphere-node-utils#taskqueue) (default is `20`). **If < 1 it throws an error**\n\n```coffeescript\nclient = new SphereClient {...} # a TaskQueue is internally initialized at this point with maxParallel of 20\nclient.setMaxParallel 5\n\n# let's trigger 100 parallel requests with `Q.all`, but process them max 5 at a time\nQ.all _.map [1..100], -> client.products.byId('123-abc').fetch()\n.then (results) ->\n```\n\n> You can pass an existing `TaskQueue` object when initializing the `SphereClient`\n\n```coffeescript\n{TaskQueue} = require 'sphere-node-utils'\ntaskQueue = new TaskQueue maxParallel: 10\nclient = new SphereClient\n  task: taskQueue\n```\n\n#### Query request\nAll resource endpoints support queries, returning a list of results of type [PagedQueryResponse](http://commercetools.de/dev/http-api.html#paged-query-response).\n\n> Fetching and endpoint without specifying and `ID` returns a `PagedQueryResponse`\n\nA query request can be configured with following query parameters:\n\n- `where` ([Predicate](http://commercetools.de/dev/http-api.html#predicates))\n- `sort` ([Sort](http://commercetools.de/dev/http-api.html#sorting))\n- `limit` (Number)\n- `offset` (Number)\n- `expand` ([Expansion Path](http://commercetools.de/dev/http-api.html#reference-expansion))\n\nThe `SphereClient` helps you build those requests with following methods:\n\n- `where(predicate)` defines a URI encoded predicate from the given string (can be set multiple times)\n- `whereOperator(operator)` defines the logical operator to combine multiple where parameters\n- `last(period)` defines a [time period](#query-for-modifications) for a query on the `lastModifiedAt` attribute of all resources\n- `sort(path, ascending)` defines how the query result should be sorted - true (default) defines ascending where as false indicates descascending\n- `page(n)` defines the page number to be requested from the complete query result (default is `1`). **If < 1 it throws an error**\n- `perPage(n)` defines the number of results to return from a query (default is `100`). If set to `0` all results are returned (_more [info](https://github.com/sphereio/sphere-node-connect#paged-requests)_). **If < 0 it throws an error**\n- `all()` alias for `perPage(0)`\n- `expand(expansionPath)` defines a URI encoded expansion path from the given string (can be set multiple times) used for expanding references of a resource\n\n> All these methods are chainable\n\n```coffeescript\n# example\n\nclient = new SphereClient {...}\nclient.products\n.where('name(en=\"Foo\")')\n.where('id=\"1234567890\"')\n.whereOperator('or')\n.page(3)\n.perPage(25)\n.sort('name', false)\n.expand('masterData.staged.productType')\n.expand('masterData.staged.categories[*]')\n.fetch()\n\n# HTTP request\n# /{project_key}/products?where=name(en%3D%22Foo%22)%20or%20id%3D%221234567890%22&limit=25&offset=50&sort=name%20desc\n```\n\n##### Query all (limit=0)\nIf you want to retrieve all results of a resource, you can set the `perPage` param to `0`, or use the alias function `all()`.\nIn that case the results are recursively requested in chunks and returned all together once completed.\n\n```coffeescript\nclient = new SphereClient {...}\nclient.perPage(0).fetch()\n.then (result) -> # `results` is still a `PagedQueryResponse` containing all results of the query\n.fail (error) ->\n```\n\nSince the request is executed recursively until all results are returned, you can **subscribe to the progress notification** in order to follow the progress\n\n```coffeescript\nclient = new SphereClient {...}\nclient.perPage(0).fetch()\n.then (result) ->\n.progress (progress) ->\n  # progress is an object containing the current progress percentage\n  # and the value of the current results (array)\n  # e.g. {percentage: 20, value: [r1, r2, r3, ...]}\n  console.log \"#{progress.percentage}% completed...\"\n.fail (error) ->\n```\n\nMore info [here](https://github.com/sphereio/sphere-node-connect#paged-requests).\n\n##### Query for modifications\nIf you want to retrieve only those resources that changed over a given time, you can chain the `last` functions,\nthat builds a query for you based on the `lastModifiedAt` attribute.\n\nThe format of the `period` parameter is a number followed by one of the following characters:\n- `s` for seconds - eg. `30s`\n- `m` for minutes - eg. `15m`\n- `h` for hours - eg. `6h`\n- `d` for days - eg. `7d`\n\n```coffeescript\n# example\n\nclient = new SphereClient {...}\nclient.orders.last('2h').fetch()\n```\n\n> Please be aware that `last` is just another `where` clause and thus depends on the `operator` you choose - default is `and`.\n\n##### Query and process in batches\nSometimes you need to query all results (or some pages) of a resource and do some other operations with those infos.\nThat means that you would need to fetch lots of data (see [query with limit 0](#query-all-limit0)) and have it all saved in memory, which can be quite dangerous and not really performant.\nTo help you with that, we provide you a `process` function to work with batches.\n> Batch processing allows to process a lot of resources in chunks. Using this approach you can balance between memory usage and parallelism.\n\nThe `process` function takes a function `fn` (which returns a _Promise_) and will start **fetching** resources in [pages](http://commercetools.de/dev/http-api.html#paged-query-response). On each page, the `fn` function will be executed and once it gets resolved, the next page will be fetched and so on.\n\n```coffeescript\n# Define your custom function, which returns a promise\nfn = (payload) ->\n  deferred = Q.defer()\n  # do something with the payload\n  if # something unexpected happens\n    deferred.reject 'BAD'\n  else # good case\n    deferred.resolve 'OK'\n  deferred.promise\n\nclient.products.perPage(20).process(fn)\n.then (result) ->\n  # here we get the total result, which is just an array of all pages accumulated\n  # eg: ['OK', 'OK', 'OK'] if you have 41 to 60 products - the function fn is called three times\n.fail (error) ->\n  # eg: 'BAD'\n```\n\nYou can pass some options as second argument:\n- `accumulate` whether the results should be accumulated or not (default `true`). If not, an empty array will be returned from the resolved promise.\n\n##### Staged products\nThe `ProductProjectionService` returns a representation of the products called [ProductProjection](http://commercetools.de/dev/http-api-projects-products.html#product-projection) which corresponds basically to a **catalog** or **staged** representation of a product. When using this service you can specify which projection of the product you would like to have by defining a `staged` parameter (default is `true`).\n\n```coffeescript\n# example\n\nclient = new SphereClient {...}\nclient.productProjections\n.staged()\n.fetch()\n\n# HTTP request\n# /{project_key}/products-projections?staged=true\n```\n\n#### Search request\nThe `ProductProjectionService` supports **searching**, returning a list of results of type [PagedQueryResponse](http://commercetools.de/dev/http-api.html#paged-query-response).\n\nA search request can be configured with following query parameters:\n\n- `lang` (ISO language tag)\n- `text` (String)\n- `filter` ([Filter](http://commercetools.de/dev/http-api-projects-products.html#search-filters))\n- `filter.query` ([Filter](http://commercetools.de/dev/http-api-projects-products.html#search-filters))\n- `filter.facets` ([Filter](http://commercetools.de/dev/http-api-projects-products.html#search-filters))\n- `facet` ([Facet](http://commercetools.de/dev/http-api-projects-products.html#search-facets))\n- `sort` ([Sort](http://commercetools.de/dev/http-api.html#sorting))\n- `limit` (Number)\n- `offset` (Number)\n- `staged` (Boolean)\n\nThe `SphereClient` helps you build those requests with following methods:\n\n- `lang(language)` defines the ISO language tag\n- `text(text)` defines the text to analyze and search for\n- `filter(filter)` defines a URI encoded string for the `filter` parameter (can be set multiple times)\n- `filterByQuery(filter)` defines a URI encoded string for the `filter.query` parameter (can be set multiple times)\n- `filterByFacets(filter)` defines a URI encoded string for the `filter.facets` parameter (can be set multiple times)\n- `facet(facet)` defines a URI encoded string for the `facet` parameter (can be set multiple times)\n- `sort(path, ascending)` defines how the query result should be sorted - true (default) defines ascending where as false indicates descascending\n- `page(n)` defines the page number to be requested from the complete query result (default is `1`). **If < 1 it throws an error**\n- `perPage(n)` defines the number of results to return from a query (default is `100`). If set to `0` all results are returned (_more [info](https://github.com/sphereio/sphere-node-connect#paged-requests)_). **If < 0 it throws an error**\n- `staged(staged)` defines whether to search for staged or current projection (see [Staged products](#staged-products))\n\n> All these methods are chainable\n\n```coffeescript\n# example\n\nclient = new SphereClient {...}\nclient.productProjections\n.page(3)\n.perPage(25)\n.sort('createdAt')\n.lang('de')\n.text('T-shirt')\n.filter('variants.attributes.color:red')\n.filterByQuery('variants.attributes.color:red')\n.filterByFacets('variants.attributes.color:red')\n.facet('variants.attributes.color:red')\n.search()\n```\n\n#### Create resource\nAll endpoints allow a resource to be created by posting a JSON `Representation` of the selected resource as a body payload.\n\n```coffeescript\nproduct =\n  name:\n    en: 'Foo'\n  slug:\n    en: 'foo'\n  ...\n\nclient.products.save(product)\n.then (result) ->\n  # a JSON object containing either a result or a SPHERE.IO HTTP error\n.fail (error) ->\n  # either the request failed or was rejected (the response returned an error)\n```\n\n> You can use also `create` instead of `save` (it's an alias)\n\n##### Import orders\nThe `OrderService` exposes a specific function to [import orders](http://commercetools.de/dev/http-api-projects-orders-import.html).\nUse it as you would use the `save` function, just internally the correct API endpoint is set.\n\n```coffeescript\nclient.orders.import(order)\n```\n\n##### Ensure channels\nThe `ChannelService` provides a convenience method to retrieve a channel with given key/role. The method ensures, that the requested channel can be returned in case it's not existing or doesn't have the requried role yet.\n\n```coffeescript\n# makes sure a channel with key 'OrderFileExport' and role 'OrderExport' exists\nclient.channels.ensure('OrderFileExport', 'OrderExport')\n.then (result) ->\n  # pretty print channel instance\n  console.log _u.prettify(result.body)\n.fail (error) ->\n  # either the request failed or was rejected (the response returned an error)\n```\n\n#### Update resource\nUpdates are just a POST request to the endpoint specified by an `ID`, provided with a body payload of [Update Actions](http://commercetools.de/dev/http-api.html#partial-updates).\n\n> The `update` method requires that the given resource `ID` is set. If no `ID` is provided it will throw an Error.\n\n```coffeescript\n# new product\nproduct =\n  name:\n    en: 'Foo'\n  slug:\n    en: 'foo'\n  ...\n\n# update action for product name\nupdate =\n  version: 1,\n  actions: [\n    {\n      action: 'changeName'\n      name:\n        en: 'Foo'\n    }\n  ]\n\nclient.products.byId('123-abc').update(product)\n.then (result) ->\n  # a JSON object containing either a result or a SPHERE.IO HTTP error\n.fail (error) ->\n  # either the request failed or was rejected (the response returned an error)\n```\n\n#### Delete resource\nSome endpoints (for now) allow a resource to be deleted by providing the `version` of current resource as a query parameter.\n\n```coffeescript\n# assume that we have a product\nclient.products.byId('123-abc').fetch()\n.then (product) ->\n  client.products.byId('123-abc').delete(product.version)\n.then (result) ->\n  # a JSON object containing either a result or a SPHERE.IO HTTP error\n.fail (error) ->\n  # either the request failed or was rejected (the response returned an error)\n```\n\n#### Types of responses\nWhen a [`Q` promise](https://github.com/kriskowal/q) is resolved or rejected a JSON object is always returned and it contains a `statusCode` plus the response body or error messages\n\n```coffeescript\n# promise resolved\n{\n  statusCode: 200 # or other successful status codes\n  body: { ... } # the body of the response coming from SPHERE.IO\n}\n\n# promise rejected\n{\n  statusCode: 400 # or other error codes\n  message: 'Oops, something went wrong' # see http://commercetools.de/dev/http-api-errors.html\n  ...\n}\n```\n\n> When a promise is rejected, the response object contains a field `originalRequest`, providing some information about the related request (`endpoint`, `payload`). This is useful to better understand the error in relation with the failed request.\n\n### Error handling\nAs the HTTP API [handles errors](https://github.com/sphereio/sphere-node-connect#error-handling) _gracefully_ by providing a JSON body with error codes and messages, the `SphereClient` handles that by providing an intuitive way of dealing with responses.\n\nSince a Promise can be either resolved or rejected, the result is determined by valuating the `statusCode` of the response:\n- `resolved` everything with a successful HTTP status code\n- `rejected` everything else\n\n**A rejected promise always contains a JSON object as following**\n\n```javascript\n// example\n{\n  \"statusCode\": 400,\n  \"message\": \"An error message\",\n  ... // other fields according to the SPHERE.IO API errors\n}\n```\n\nThe client application can then easily decide what to do\n\n```coffeescript\nclient.products.save({})\n.then (result) ->\n  # we know the request was successful (e.g.: 2xx) and `result` is a JSON of a resource representation\n.fail (error) ->\n  # something went wrong, either an unexpected error or a HTTP API error response\n  # here we can check the `statusCode` to differentiate the error\n  switch error.statusCode\n    when 400 then # do something\n    when 500 then # do something\n    ...\n    else # do something else\n```\n\n### Logging\nLogging is supported by the lightweight JSON logging module called [Bunyan](https://github.com/trentm/node-bunyan).\nThe `SphereClient` uses by default an easier implementation of bunyan in order to provide an easier interface for sharing a logger across multiple modules that supports this. You can see the documentation [here](https://github.com/sphereio/sphere-node-utils#logger) for full configuration.\n\nExamples:\n```coffeescript\n# this will logs to stdout with level INFO and to a log file with level ERROR\nclient = new SphereClient\n  logConfig:\n    levelStream: 'info'\n    levelFile: 'error'\n\n# this will logs only to stdout with level INFO\nclient = new SphereClient\n  logConfig:\n    streams: [\n      {level: 'info', stream: process.stdout}\n    ]\n\n# this will logs only to file with level DEBUG\nclient = new SphereClient\n  logConfig:\n    path: './sphere-node-utils-debug.log'\n    levelFile: 'debug'\n```\n\n> You can pass an existing `Logger` object when initializing the `SphereClient`\n\n```coffeescript\n{Logger} = require 'sphere-node-utils'\nclass MyCustomLogger extends Logger\n  @appName: 'my-application-name'\n\nmyLogger = new MyCustomLogger logConfig\n\n# assume we have a component which already implements logging\nclient = new SphereClient\n  logConfig:\n    logger: myLogger\n```\n\n\n> If you want to wrap additional fields to the logged JSON object, you can use our [ExtendedLogger](https://github.com/sphereio/sphere-node-utils#extendedlogger)\n\n### Statistics\nYou can retrieve some statistics (more to come) by passing some options when creating a new `SphereClient` instance.\n\nCurrent options are available:\n\n- `includeHeaders` will include some HTTP header information in the [response](#types-of-responses), wrapped in a JSON object called `http`\n\n```coffeescript\nclient = new SphereClient\n  config: # credentials\n  stats:\n    includeHeaders: true\n```\n\n```javascript\n{\n  \"http\": { // HTTP header information\n    \"request\": {\n      \"method\": \"GET\",\n      \"httpVersion\": \"1.1\",\n      \"uri\": {\n        \"protocol\": \"https:\",\n        \"slashes\": true,\n        \"auth\": null,\n        \"host\": \"api.sphere.io\",\n        \"port\": 443,\n        \"hostname\": \"api.sphere.io\",\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/foo/bar\",\n        \"path\": \"/foo/bar\",\n        \"href\": \"https://api.sphere.io/foo/bar\",\n      },\n      \"header\": \"GET /foo/bar HTTP/1.1\\r\\nUser-Agent: sphere-node-client\\r\\nAuthorization: Bearer XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\r\\nhost: api.sphere.io\\r\\naccept: application/json\\r\\nConnection: keep-alive\\r\\n\\r\\n\",\n      \"headers\": {\n        \"User-Agent\": \"sphere-node-client\",\n        \"Authorization\": \"Bearer XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"accept\": \"application/json\"\n      }\n    },\n    \"response\": {\n      \"headers\": {\n        \"server\": \"nginx\",\n        \"date\": \"Wed, 01 Jan 2014 12:00:00 GMT\",\n        \"content-type\": \"application/json; charset=utf-8\",\n        \"transfer-encoding\": \"chunked\",\n        \"connection\": \"keep-alive\",\n        \"x-served-by\": \"app2.sphere.prod.commercetools.de\",\n        \"x-served-config\": \"sphere-projects-ws-1.0\",\n        \"access-control-allow-origin\": \"*\",\n        \"access-control-allow-headers\": \"Accept, Authorization, Content-Type, Origin\",\n        \"access-control-allow-methods\": \"GET, POST, DELETE, OPTIONS\"\n      }\n    }\n  }\n  \"statusCode\": 200\n  \"body\": { ... }\n}\n\n```\n\n## Examples\n_(Coming soon)_\n\n## Contributing\nIn lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code using [Grunt](http://gruntjs.com/).\nMore info [here](CONTRIBUTING.md)\n\n## Releasing\nReleasing a new version is completely automated using the Grunt task `grunt release`.\n\n```javascript\ngrunt release // patch release\ngrunt release:minor // minor release\ngrunt release:major // major release\n```\n\n## License\nCopyright (c) 2014 SPHERE.IO\nLicensed under the [MIT license](LICENSE-MIT).\n",
  "readmeFilename": "README.md",
  "_id": "sphere-node-client@0.8.1",
  "_from": "sphere-node-client@^0.8.0"
}
